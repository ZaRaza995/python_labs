# Лабораторная работа №10: Структуры данных

## Описание
В рамках данной лабораторной работы были реализованы три фундаментальные структуры данных:
1. **Стек (Stack)**
2. **Очередь (Queue)**
3. **Односвязный список (Singly Linked List)**

Основная цель работы — понять асимптотическую сложность (Big O) основных операций и научиться выбирать подходящие структуры данных для конкретных задач.

## Реализация

### 1. Stack (Стек)
Реализован в файле [`structures.py`](./structures.py).
*   **Базовая структура:** Стандартный список Python (`list`).
*   **Принцип работы:** LIFO (Last In, First Out — "последним пришел, первым ушел").
*   **Сложность операций:**
    *   `push` (добавление): **O(1)** (амортизированная).
    *   `pop` (удаление): **O(1)**.
    *   `peek` (просмотр верхушки): **O(1)**.

### 2. Queue (Очередь)
Реализована в файле [`structures.py`](./structures.py).
*   **Базовая структура:** `collections.deque`.
*   **Принцип работы:** FIFO (First In, First Out — "первым пришел, первым ушел").
*   **Важно:** Использование обычного `list` для очереди неэффективно, так как удаление первого элемента (`pop(0)`) приводит к сдвигу всех остальных элементов (сложность O(n)). `deque` позволяет выполнять операции с обоих концов за O(1).
*   **Сложность операций:**
    *   `enqueue` (добавление): **O(1)**.
    *   `dequeue` (удаление): **O(1)**.
    *   `peek` (просмотр первого): **O(1)**.

### 3. SinglyLinkedList (Односвязный список)
Реализован в файле [`linked_list.py`](./linked_list.py).
*   **Структура:** Цепочка узлов (`Node`), где каждый узел хранит значение и ссылку на следующий узел (`next`).
*   **Оптимизация:** Реализовано хранение ссылки не только на голову (`head`), но и на хвост (`tail`) списка.
*   **Сложность операций:**
    *   `append` (вставка в конец): **O(1)** (благодаря наличию `tail`, иначе было бы O(n)).
    *   `prepend` (вставка в начало): **O(1)**.
    *   `insert` (вставка по индексу): **O(n)** (требуется проход по списку до нужной позиции).
    *   `remove` (удаление по значению): **O(n)** (требуется поиск элемента).

## Теоретическая справка (Q&A)

### В чем разница между массивом (Python `list`) и связным списком?
| Характеристика | Массив (`list`) | Связный список (`LinkedList`) |
|----------------|-----------------|-------------------------------|
| **Доступ по индексу** | **O(1)** (мгновенно) | **O(n)** (нужно перебирать) |
| **Вставка в начало** | **O(n)** (сдвиг элементов) | **O(1)** (перекинуть ссылку) |
| **Вставка в середину** | **O(n)** | **O(1)** (если есть ссылка на узел) |
| **Память** | Эффективно, но требует перевыделения при росте | Требует доп. памяти на ссылки (`next`) |

### Почему для Queue мы использовали `deque`?
Стандартный `list` в Python — это динамический массив. При удалении элемента из начала массива (`pop(0)`) интерпретатору приходится перемещать все оставшиеся элементы на одну позицию влево, чтобы закрыть "дыру". Это занимает время, пропорциональное длине списка (**O(n)**).
`collections.deque` (Double Ended Queue) реализован как двусвязный список блоков, что позволяет добавлять и удалять элементы с обоих концов за фиксированное время (**O(1)**).

### Зачем нужен атрибут `tail` в LinkedList?
Без атрибута `tail` (хвост), чтобы добавить элемент в конец списка, нам пришлось бы начинать с `head` и проходить по ссылкам `next` до самого конца, чтобы найти последний узел. Это операция **O(n)**.
Сохраняя ссылку на последний элемент в `tail`, мы можем сразу добавить новый узел после него, превращая операцию `append` в **O(1)**.
